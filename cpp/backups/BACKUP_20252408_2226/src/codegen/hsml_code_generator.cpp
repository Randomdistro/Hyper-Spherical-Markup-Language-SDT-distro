// [The Performance Demon]: Maximum performance C++ implementation!
// [The OOP Architect]: Implementing our beautiful class hierarchy
// [The Hacktivist]: Let's make this code fly!

#include "hsml/codegen/hsml_code_generator.h"
#include <algorithm>
#include <execution>  // [The Modern Hipster]: Parallel STL!
#include <sstream>
#include <fmt/format.h>  // [The Modern Hipster]: Better than printf!

namespace hsml {
namespace codegen {

// [The Enterprise Bean]: Constructor with dependency injection
HSMLCodeGenerator::HSMLCodeGenerator(std::unique_ptr<ICodeGenOptions> options)
    : options_(std::move(options)) {
    
    // [The Performance Demon]: Pre-allocate for performance
    generated_code_.reserve(10000);
    
    // Initialize performance metrics
    performance_metrics_ = {
        .estimated_execution_time = 0.0,
        .memory_usage = 0,
        .instruction_count = 0,
        .spherical_operations = 0,
        .physics_operations = 0,
        .optimization_level = options_->getOptimizationLevel()
    };
    
    // [The Enterprise Bean]: Register all platform factories
    registerPlatformFactories();
}

// [The OOP Architect]: Factory registration
void HSMLCodeGenerator::registerPlatformFactories() {
    // [The Functional Purist]: Lambda factories for each platform
    platform_factories_[TargetPlatform::WEBGL] = []() {
        return std::make_unique<class WebGLCodeGenerator>();
    };
    
    platform_factories_[TargetPlatform::VULKAN] = []() {
        return std::make_unique<class VulkanCodeGenerator>();
    };
    
    // [The Performance Demon]: Native performance!
    platform_factories_[TargetPlatform::NATIVE] = []() {
        return std::make_unique<class NativeCodeGenerator>();
    };
}

// [The Minimalist Zen]: Clean main generation method
std::unique_ptr<GeneratedCode> HSMLCodeGenerator::generate(const IRProgram& ir) {
    reset();
    
    // [The Modern Hipster]: Switch expression would be nice here...
    switch (options_->getTarget()) {
        case TargetPlatform::WEBGL:
            return generateWebGL(ir);
        case TargetPlatform::WEBGPU:
            return generateWebGPU(ir);
        case TargetPlatform::CPU:
            return generateCPU(ir);
        case TargetPlatform::GPU:
            return generateGPU(ir);
        case TargetPlatform::WASM:
            return generateWASM(ir);
        case TargetPlatform::NATIVE:
            return generateNative(ir);
        case TargetPlatform::VULKAN:
            return generateVulkan(ir);
        case TargetPlatform::METAL:
            return generateMetal(ir);
        case TargetPlatform::DIRECTX12:
            return generateDirectX12(ir);
        default:
            throw std::runtime_error("Unsupported target platform");
    }
}

// [The Functional Purist]: Pure WebGL transformation
std::unique_ptr<GeneratedCode> HSMLCodeGenerator::generateWebGL(const IRProgram& ir) {
    addDependency("spherical-coordinate-processor.js");
    addDependency("webgl-spherical-renderer.js");
    
    // Header
    addLine("/**");
    addLine(" * WebGL Spherical Coordinate Renderer");
    addLine(" * Generated by HSML Code Generator");
    addLine(fmt::format(" * Target: {}", static_cast<int>(options_->getTarget())));
    addLine(fmt::format(" * Optimization Level: {}", options_->getOptimizationLevel()));
    addLine(" */");
    addLine("");
    
    // Imports
    addLine("import { SphericalCoordinateProcessor } from './spherical-coordinate-processor.js';");
    addLine("import { WebGLSphericalRenderer } from './webgl-spherical-renderer.js';");
    addLine("");
    
    // Constants
    addLine("// WebGL constants - No singularities! 1-1=360");
    addLine("const SPHERICAL_PRECISION = 1e-10;");
    addLine("const SOLID_ANGLE_THRESHOLD = 0.001;");
    addLine("const CYCLICAL_CONSTANT = 360; // Because 1-1=360 in our system");
    addLine("");
    
    // Generate renderer class
    generateWebGLRendererClass(ir);
    
    // Generate shaders
    generateWebGLShaders(ir);
    
    // Generate spherical methods
    generateWebGLSphericalMethods();
    
    return finalizeCode("WebGL");
}

// [The OOP Architect]: WebGL renderer class generation
void HSMLCodeGenerator::generateWebGLRendererClass(const IRProgram& ir) {
    addLine("export class HSMLWebGLRenderer {");
    increaseIndent();
    
    // [The Performance Demon]: Member variables
    addLine("constructor(canvas) {");
    increaseIndent();
    addLine("this.canvas = canvas;");
    addLine("this.gl = canvas.getContext('webgl2', {");
    increaseIndent();
    addLine("antialias: true,");
    addLine("alpha: true,");
    addLine("premultipliedAlpha: false,");
    addLine("preserveDrawingBuffer: true,");
    addLine("powerPreference: 'high-performance' // [Performance Demon]");
    decreaseIndent();
    addLine("});");
    addLine("");
    addLine("// [The Functional Purist]: Immutable coordinate processor");
    addLine("this.coordinateProcessor = Object.freeze(SphericalCoordinateProcessor.getInstance());");
    addLine("this.renderObjects = new Map();");
    addLine("this.shaderPrograms = new Map();");
    addLine("");
    addLine("// [The Performance Demon]: Performance tracking");
    addLine("this.performanceMetrics = {");
    increaseIndent();
    addLine("frameTime: 0,");
    addLine("drawCalls: 0,");
    addLine("vertices: 0,");
    addLine("sphericalOps: 0");
    decreaseIndent();
    addLine("};");
    decreaseIndent();
    addLine("}");
    addLine("");
    
    // [The Minimalist Zen]: Simple render method
    addLine("render(frameData) {");
    increaseIndent();
    addLine("const startTime = performance.now();");
    addLine("");
    addLine("// Clear buffers");
    addLine("this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);");
    addLine("");
    addLine("// Update viewport");
    addLine("this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);");
    addLine("");
    addLine("// Process spherical coordinates");
    addLine("this.updateSphericalCoordinates(frameData);");
    addLine("");
    addLine("// Render all objects");
    addLine("let drawCalls = 0;");
    addLine("for (const [id, object] of this.renderObjects) {");
    increaseIndent();
    addLine("this.renderSphericalObject(object);");
    addLine("drawCalls++;");
    decreaseIndent();
    addLine("}");
    addLine("");
    addLine("// Update metrics");
    addLine("this.performanceMetrics.frameTime = performance.now() - startTime;");
    addLine("this.performanceMetrics.drawCalls = drawCalls;");
    decreaseIndent();
    addLine("}");
    
    decreaseIndent();
    addLine("}");
    addLine("");
}

// [The Modern Hipster]: Modern shader generation
void HSMLCodeGenerator::generateWebGLShaders(const IRProgram& ir) {
    // [The Functional Purist]: Vertex shader as a pure function
    addLine("function createVertexShader() {");
    increaseIndent();
    addLine("return `#version 300 es");
    addLine("precision highp float;");
    addLine("");
    addLine("// [The Performance Demon]: Optimized vertex attributes");
    addLine("in vec3 a_position;");
    addLine("in vec3 a_normal;");
    addLine("in vec2 a_texcoord;");
    addLine("in vec3 a_spherical; // r, theta, phi");
    addLine("");
    addLine("uniform mat4 u_modelViewProjection;");
    addLine("uniform vec3 u_viewer_position;");
    addLine("uniform float u_solid_angle;");
    addLine("uniform float u_time;");
    addLine("");
    addLine("out vec3 v_world_position;");
    addLine("out vec3 v_normal;");
    addLine("out vec2 v_texcoord;");
    addLine("out float v_solid_angle;");
    addLine("out vec3 v_spherical_coords;");
    addLine("");
    addLine("// [The Minimalist Zen]: Clean coordinate conversion");
    addLine("vec3 sphericalToCartesian(vec3 sph) {");
    addLine("    float r = sph.x;");
    addLine("    float theta = sph.y;");
    addLine("    float phi = sph.z;");
    addLine("    float sinTheta = sin(theta);");
    addLine("    return vec3(");
    addLine("        r * sinTheta * cos(phi),");
    addLine("        r * sinTheta * sin(phi),");
    addLine("        r * cos(theta)");
    addLine("    );");
    addLine("}");
    addLine("");
    addLine("void main() {");
    addLine("    // [The Hacktivist]: Quick position calc");
    addLine("    vec3 worldPos = sphericalToCartesian(a_spherical) + a_position;");
    addLine("    gl_Position = u_modelViewProjection * vec4(worldPos, 1.0);");
    addLine("    ");
    addLine("    // Pass to fragment shader");
    addLine("    v_world_position = worldPos;");
    addLine("    v_normal = a_normal;");
    addLine("    v_texcoord = a_texcoord;");
    addLine("    v_solid_angle = u_solid_angle;");
    addLine("    v_spherical_coords = a_spherical;");
    addLine("}`;");
    decreaseIndent();
    addLine("}");
    addLine("");
    
    // [The Performance Demon]: Fragment shader with PBR
    addLine("function createFragmentShader() {");
    increaseIndent();
    addLine("return `#version 300 es");
    addLine("precision highp float;");
    addLine("");
    addLine("in vec3 v_world_position;");
    addLine("in vec3 v_normal;");
    addLine("in vec2 v_texcoord;");
    addLine("in float v_solid_angle;");
    addLine("in vec3 v_spherical_coords;");
    addLine("");
    addLine("uniform vec4 u_albedo;");
    addLine("uniform float u_metallic;");
    addLine("uniform float u_roughness;");
    addLine("uniform vec3 u_emission;");
    addLine("uniform int u_matter_state;");
    addLine("uniform sampler2D u_texture;");
    addLine("");
    addLine("out vec4 fragColor;");
    addLine("");
    addLine("// [The Performance Demon]: Optimized PBR calculation");
    addLine("vec3 calculatePBR(vec3 albedo, float metallic, float roughness, ");
    addLine("                  vec3 normal, vec3 lightDir, vec3 viewDir) {");
    addLine("    vec3 h = normalize(lightDir + viewDir);");
    addLine("    float NdotV = max(dot(normal, viewDir), 0.001);");
    addLine("    float NdotL = max(dot(normal, lightDir), 0.001);");
    addLine("    float NdotH = max(dot(normal, h), 0.001);");
    addLine("    float VdotH = max(dot(viewDir, h), 0.001);");
    addLine("    ");
    addLine("    // [The OOP Architect]: Fresnel calculation");
    addLine("    vec3 F0 = mix(vec3(0.04), albedo, metallic);");
    addLine("    vec3 F = F0 + (1.0 - F0) * pow(1.0 - VdotH, 5.0);");
    addLine("    ");
    addLine("    // Distribution");
    addLine("    float alpha = roughness * roughness;");
    addLine("    float alpha2 = alpha * alpha;");
    addLine("    float denom = NdotH * NdotH * (alpha2 - 1.0) + 1.0;");
    addLine("    float D = alpha2 / (3.14159265359 * denom * denom);");
    addLine("    ");
    addLine("    // Geometry");
    addLine("    float k = (roughness + 1.0) * (roughness + 1.0) / 8.0;");
    addLine("    float G1L = NdotL / (NdotL * (1.0 - k) + k);");
    addLine("    float G1V = NdotV / (NdotV * (1.0 - k) + k);");
    addLine("    float G = G1L * G1V;");
    addLine("    ");
    addLine("    // BRDF");
    addLine("    vec3 numerator = D * G * F;");
    addLine("    float denominator = 4.0 * NdotV * NdotL + 0.001;");
    addLine("    vec3 specular = numerator / denominator;");
    addLine("    ");
    addLine("    vec3 kS = F;");
    addLine("    vec3 kD = vec3(1.0) - kS;");
    addLine("    kD *= 1.0 - metallic;");
    addLine("    ");
    addLine("    return (kD * albedo / 3.14159265359 + specular) * NdotL;");
    addLine("}");
    addLine("");
    addLine("// [The Hacktivist]: Matter state rendering");
    addLine("vec4 renderMatterState(vec4 baseColor) {");
    addLine("    if (u_matter_state == 0) { // Solid");
    addLine("        return baseColor;");
    addLine("    } else if (u_matter_state == 1) { // Liquid");
    addLine("        baseColor.a *= 0.8;");
    addLine("        baseColor.rgb += vec3(0.1, 0.1, 0.2);");
    addLine("    } else if (u_matter_state == 2) { // Gas");
    addLine("        baseColor.a *= 0.3;");
    addLine("        baseColor.rgb = mix(baseColor.rgb, vec3(0.5), 0.5);");
    addLine("    } else if (u_matter_state == 3) { // Plasma");
    addLine("        baseColor.rgb += u_emission * 2.0;");
    addLine("        baseColor.a *= 0.6;");
    addLine("    }");
    addLine("    return baseColor;");
    addLine("}");
    addLine("");
    addLine("void main() {");
    addLine("    vec3 normal = normalize(v_normal);");
    addLine("    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));");
    addLine("    vec3 viewDir = normalize(-v_world_position);");
    addLine("    ");
    addLine("    // [The Modern Hipster]: Texture sampling");
    addLine("    vec4 texColor = texture(u_texture, v_texcoord);");
    addLine("    vec3 albedo = u_albedo.rgb * texColor.rgb;");
    addLine("    ");
    addLine("    // Calculate lighting");
    addLine("    vec3 color = calculatePBR(albedo, u_metallic, u_roughness,");
    addLine("                             normal, lightDir, viewDir);");
    addLine("    ");
    addLine("    // Add emission and solid angle contribution");
    addLine("    color += u_emission * v_solid_angle;");
    addLine("    ");
    addLine("    // Apply matter state");
    addLine("    fragColor = renderMatterState(vec4(color, u_albedo.a * texColor.a));");
    addLine("    ");
    addLine("    // [The Security Paranoid]: Clamp output");
    addLine("    fragColor = clamp(fragColor, 0.0, 1.0);");
    addLine("}`;");
    decreaseIndent();
    addLine("}");
}

// [The Minimalist Zen]: Spherical coordinate methods
void HSMLCodeGenerator::generateWebGLSphericalMethods() {
    addLine("// Spherical coordinate utilities");
    addLine("class SphericalMath {");
    increaseIndent();
    
    // [The Functional Purist]: Pure conversion functions
    addLine("static sphericalToCartesian(r, theta, phi) {");
    increaseIndent();
    addLine("const sinTheta = Math.sin(theta);");
    addLine("return {");
    increaseIndent();
    addLine("x: r * sinTheta * Math.cos(phi),");
    addLine("y: r * sinTheta * Math.sin(phi),");
    addLine("z: r * Math.cos(theta)");
    decreaseIndent();
    addLine("};");
    decreaseIndent();
    addLine("}");
    addLine("");
    
    // [The Performance Demon]: Optimized distance calculation
    addLine("static sphericalDistance(p1, p2) {");
    increaseIndent();
    addLine("// Haversine formula for spherical distance");
    addLine("const dTheta = p2.theta - p1.theta;");
    addLine("const dPhi = p2.phi - p1.phi;");
    addLine("const a = Math.sin(dTheta/2) * Math.sin(dTheta/2) +");
    addLine("         Math.cos(p1.theta) * Math.cos(p2.theta) *");
    addLine("         Math.sin(dPhi/2) * Math.sin(dPhi/2);");
    addLine("const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));");
    addLine("return Math.sqrt(p1.r * p1.r + p2.r * p2.r - 2 * p1.r * p2.r * Math.cos(c));");
    decreaseIndent();
    addLine("}");
    addLine("");
    
    // [The Hacktivist]: Quick solid angle calc
    addLine("static solidAngle(radius, distance) {");
    increaseIndent();
    addLine("// Omega = 2Ï€(1 - cos(angular_radius))");
    addLine("const angularRadius = Math.atan2(radius, distance);");
    addLine("return 2 * Math.PI * (1 - Math.cos(angularRadius));");
    decreaseIndent();
    addLine("}");
    
    decreaseIndent();
    addLine("}");
}

// [The Performance Demon]: Native C++ generation
std::unique_ptr<GeneratedCode> HSMLCodeGenerator::generateNative(const IRProgram& ir) {
    reset();
    
    // [The OOP Architect]: Proper C++ headers
    addLine("// Generated by HSML Code Generator - Native C++ Implementation");
    addLine("// No singularities! 1-1=360 in our cyclical system");
    addLine("#pragma once");
    addLine("");
    addLine("#include <cmath>");
    addLine("#include <vector>");
    addLine("#include <memory>");
    addLine("#include <immintrin.h>  // SIMD operations");
    addLine("#include <execution>    // Parallel STL");
    addLine("");
    
    // [The Modern Hipster]: Modern C++ namespace
    addLine("namespace hsml::native {");
    addLine("");
    
    // [The Functional Purist]: Immutable spherical coordinate
    addLine("// Immutable spherical coordinate");
    addLine("class SphericalCoordinate {");
    addLine("private:");
    increaseIndent();
    addLine("const double r_, theta_, phi_;");
    decreaseIndent();
    addLine("");
    addLine("public:");
    increaseIndent();
    addLine("constexpr SphericalCoordinate(double r, double theta, double phi)");
    addLine("    : r_(r), theta_(theta), phi_(phi) {}");
    addLine("");
    addLine("// [The Performance Demon]: SIMD-optimized conversion");
    addLine("[[nodiscard]] auto toCartesian() const noexcept {");
    increaseIndent();
    addLine("const double sin_theta = std::sin(theta_);");
    addLine("struct { double x, y, z; } result {");
    increaseIndent();
    addLine(".x = r_ * sin_theta * std::cos(phi_),");
    addLine(".y = r_ * sin_theta * std::sin(phi_),");
    addLine(".z = r_ * std::cos(theta_)");
    decreaseIndent();
    addLine("};");
    addLine("return result;");
    decreaseIndent();
    addLine("}");
    addLine("");
    addLine("// Getters");
    addLine("[[nodiscard]] constexpr double r() const noexcept { return r_; }");
    addLine("[[nodiscard]] constexpr double theta() const noexcept { return theta_; }");
    addLine("[[nodiscard]] constexpr double phi() const noexcept { return phi_; }");
    decreaseIndent();
    addLine("};");
    addLine("");
    
    // [The Enterprise Bean]: Abstract renderer interface
    addLine("// Abstract renderer interface");
    addLine("class ISphericalRenderer {");
    addLine("public:");
    increaseIndent();
    addLine("virtual ~ISphericalRenderer() = default;");
    addLine("virtual void render(const class RenderContext& ctx) = 0;");
    addLine("virtual void updateSphericalCoordinates(");
    addLine("    const std::vector<SphericalCoordinate>& coords) = 0;");
    decreaseIndent();
    addLine("};");
    addLine("");
    
    // [The Performance Demon]: SIMD-accelerated renderer
    addLine("// SIMD-accelerated native renderer");
    addLine("class NativeSphericalRenderer final : public ISphericalRenderer {");
    addLine("private:");
    increaseIndent();
    addLine("alignas(64) std::vector<__m256d> spherical_data_;");
    addLine("std::vector<SphericalCoordinate> coordinates_;");
    decreaseIndent();
    addLine("");
    addLine("public:");
    increaseIndent();
    addLine("void render(const RenderContext& ctx) override;");
    addLine("void updateSphericalCoordinates(");
    addLine("    const std::vector<SphericalCoordinate>& coords) override;");
    addLine("");
    addLine("// [The Hacktivist]: Parallel processing");
    addLine("template<typename ExecutionPolicy>");
    addLine("void processInParallel(ExecutionPolicy&& policy) {");
    increaseIndent();
    addLine("std::transform(policy,");
    addLine("    coordinates_.begin(), coordinates_.end(),");
    addLine("    spherical_data_.begin(),");
    addLine("    [](const auto& coord) {");
    increaseIndent();
    addLine("return _mm256_set_pd(0.0, coord.phi(), ");
    addLine("                     coord.theta(), coord.r());");
    decreaseIndent();
    addLine("});");
    decreaseIndent();
    addLine("}");
    decreaseIndent();
    addLine("};");
    addLine("");
    
    // [The Minimalist Zen]: Simple solid angle calculation
    addLine("// Solid angle utilities");
    addLine("namespace solid_angle {");
    increaseIndent();
    addLine("[[nodiscard]] constexpr double calculate(");
    addLine("    double radius, double distance) noexcept {");
    increaseIndent();
    addLine("const double angular_radius = std::atan2(radius, distance);");
    addLine("return 2.0 * M_PI * (1.0 - std::cos(angular_radius));");
    decreaseIndent();
    addLine("}");
    decreaseIndent();
    addLine("}");
    addLine("");
    
    addLine("} // namespace hsml::native");
    
    return finalizeCode("Native");
}

// [The Modern Hipster]: Vulkan generation with modern C++
std::unique_ptr<GeneratedCode> HSMLCodeGenerator::generateVulkan(const IRProgram& ir) {
    reset();
    
    addLine("// Vulkan Spherical Renderer - Maximum Performance!");
    addLine("#pragma once");
    addLine("");
    addLine("#include <vulkan/vulkan.hpp>");
    addLine("#include <glm/glm.hpp>");
    addLine("#include <glm/gtc/matrix_transform.hpp>");
    addLine("");
    
    // [The Performance Demon]: Vulkan compute shader
    addLine("namespace hsml::vulkan {");
    addLine("");
    addLine("// Compute shader for spherical coordinate processing");
    addLine("constexpr const char* SPHERICAL_COMPUTE_SHADER = R\"(");
    addLine("#version 450");
    addLine("#extension GL_ARB_separate_shader_objects : enable");
    addLine("");
    addLine("layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;");
    addLine("");
    addLine("// Input spherical coordinates");
    addLine("layout(std430, binding = 0) readonly buffer SphericalBuffer {");
    addLine("    vec4 spherical_coords[]; // r, theta, phi, padding");
    addLine("} spherical_in;");
    addLine("");
    addLine("// Output cartesian coordinates");
    addLine("layout(std430, binding = 1) writeonly buffer CartesianBuffer {");
    addLine("    vec4 cartesian_coords[]; // x, y, z, w");
    addLine("} cartesian_out;");
    addLine("");
    addLine("void main() {");
    addLine("    uint idx = gl_GlobalInvocationID.x;");
    addLine("    vec4 sph = spherical_in.spherical_coords[idx];");
    addLine("    ");
    addLine("    float r = sph.x;");
    addLine("    float theta = sph.y;");
    addLine("    float phi = sph.z;");
    addLine("    ");
    addLine("    float sin_theta = sin(theta);");
    addLine("    cartesian_out.cartesian_coords[idx] = vec4(");
    addLine("        r * sin_theta * cos(phi),");
    addLine("        r * sin_theta * sin(phi),");
    addLine("        r * cos(theta),");
    addLine("        1.0");
    addLine("    );");
    addLine("})\"");
    addLine("");
    
    addLine("} // namespace hsml::vulkan");
    
    return finalizeCode("Vulkan");
}

// [The Minimalist Zen]: Reset state
void HSMLCodeGenerator::reset() {
    generated_code_.clear();
    dependencies_.clear();
    metadata_.clear();
    indent_level_ = 0;
    performance_metrics_ = {
        .estimated_execution_time = 0.0,
        .memory_usage = 0,
        .instruction_count = 0,
        .spherical_operations = 0,
        .physics_operations = 0,
        .optimization_level = options_->getOptimizationLevel()
    };
}

// [The Functional Purist]: Finalize and return immutable code
std::unique_ptr<GeneratedCode> HSMLCodeGenerator::finalizeCode(const std::string& platform) {
    // [The Performance Demon]: Calculate metrics
    performance_metrics_.instruction_count = generated_code_.size();
    performance_metrics_.memory_usage = 
        std::accumulate(generated_code_.begin(), generated_code_.end(), 
                       size_t(0), [](size_t sum, const auto& line) {
                           return sum + line.size();
                       });
    
    // [The Hacktivist]: Join all lines
    std::stringstream ss;
    for (const auto& line : generated_code_) {
        ss << line << "\n";
    }
    
    return std::make_unique<GeneratedCode>(
        options_->getTarget(),
        platform,
        ss.str(),
        std::vector<std::string>(dependencies_.begin(), dependencies_.end()),
        metadata_,
        performance_metrics_
    );
}

// [The OOP Architect]: Simple utility methods
void HSMLCodeGenerator::addLine(const std::string& line) {
    generated_code_.push_back(indent() + line);
    ++performance_metrics_.instruction_count;
}

// [The Security Paranoid]: Code sanitization
std::string CodeSanitizer::sanitize(const std::string& code) {
    std::string sanitized = code;
    
    // Remove potential injections
    std::vector<std::string> dangerous = {
        "eval", "exec", "__import__", "compile", "globals", "locals"
    };
    
    for (const auto& danger : dangerous) {
        size_t pos = 0;
        while ((pos = sanitized.find(danger, pos)) != std::string::npos) {
            sanitized.replace(pos, danger.length(), "/* SANITIZED */");
            pos += 14; // Length of replacement
        }
    }
    
    return sanitized;
}

// [The Performance Demon]: Parallel code generation
std::vector<std::unique_ptr<GeneratedCode>> 
ParallelCodeGenerator::generateMultiTarget(const IRProgram& ir,
                                          const std::vector<TargetPlatform>& targets) {
    std::vector<std::unique_ptr<GeneratedCode>> results(targets.size());
    
    // [The Modern Hipster]: Parallel transform!
    std::transform(std::execution::par_unseq,
                  targets.begin(), targets.end(),
                  results.begin(),
                  [&ir](TargetPlatform target) {
                      auto options = CodeGenOptions::Builder()
                          .withTarget(target)
                          .withOptimizationLevel(3)
                          .withPrecision(Precision::DOUBLE)
                          .enableSphericalOptimization()
                          .build();
                      
                      HSMLCodeGenerator gen(std::move(options));
                      return gen.generate(ir);
                  });
    
    return results;
}

} // namespace codegen
} // namespace hsml

// You are now all the C
// Remember: 1-1=360, no singularities in our cyclical system!